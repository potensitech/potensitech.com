const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { execSync } = require('child_process');
const axios = require('axios');
const toml = require('toml');

// Paths
const configPath = path.join(__dirname, '..', '..', 'config.toml');
const indexingConfigPath = path.join(__dirname, 'indexing-config.json');

// Function to read baseURL from config.toml
function getBaseUrl() {
  const configContent = fs.readFileSync(configPath, 'utf-8');
  const config = toml.parse(configContent);
  return config.baseURL.endsWith('/') ? config.baseURL.slice(0, -1) : config.baseURL;
}

// Function to load indexing configuration
function loadIndexingConfig() {
  try {
    const configContent = fs.readFileSync(indexingConfigPath, 'utf-8');
    return JSON.parse(configContent);
  } catch (error) {
    console.error('Error loading indexing config:', error.message);
    return {
      searchConsoleApi: { enabled: false },
      indexNow: { enabled: true, submitRecentOnly: true, hoursThreshold: 24 },
      pingServices: { retryAttempts: 2, delayBetweenPings: 500 }
    };
  }
}

// Function to save indexing configuration
function saveIndexingConfig(config) {
  try {
    fs.writeFileSync(indexingConfigPath, JSON.stringify(config, null, 2));
    console.log('âœ“ Indexing configuration saved');
  } catch (error) {
    console.error('âœ— Failed to save indexing config:', error.message);
  }
}

// Function to generate IndexNow key automatically
function generateIndexNowKey() {
  // Generate 64-character hexadecimal key
  return crypto.randomBytes(32).toString('hex');
}

// Function to auto-configure IndexNow
function autoConfigureIndexNow() {
  console.log('=== Auto-configuring IndexNow ===');
  
  const config = loadIndexingConfig();
  let indexNowKey = process.env.INDEXNOW_KEY;
  let keyWasGenerated = false;
  
  // Check if key exists
  if (!indexNowKey) {
    console.log('âš  IndexNow key not found in environment variables');
    
    // Check if key exists in config file
    if (config.indexNow && config.indexNow.key) {
      indexNowKey = config.indexNow.key;
      console.log('âœ“ Using existing key from config file');
    } else {
      // Generate new key
      indexNowKey = generateIndexNowKey();
      keyWasGenerated = true;
      console.log('âœ“ Generated new IndexNow key');
      
      // Save to config
      config.indexNow = config.indexNow || {};
      config.indexNow.key = indexNowKey;
      config.indexNow.enabled = true;
      config.indexNow.autoGenerated = true;
      config.indexNow.generatedAt = new Date().toISOString();
      
      saveIndexingConfig(config);
    }
  } else {
    console.log('âœ“ Using IndexNow key from environment variable');
  }
  
  // Generate key file for verification
  const keyFilePath = path.join(__dirname, '..', '..', 'static', 'indexnow-key.txt');
  const publicKeyPath = path.join(__dirname, '..', '..', 'public', 'indexnow-key.txt');
  
  try {
    // Ensure directories exist
    const staticDir = path.dirname(keyFilePath);
    const publicDir = path.dirname(publicKeyPath);
    
    if (!fs.existsSync(staticDir)) {
      fs.mkdirSync(staticDir, { recursive: true });
    }
    if (!fs.existsSync(publicDir)) {
      fs.mkdirSync(publicDir, { recursive: true });
    }
    
    // Write key files
    fs.writeFileSync(keyFilePath, indexNowKey);
    fs.writeFileSync(publicKeyPath, indexNowKey);
    
    console.log('âœ“ IndexNow key files created');
    
    if (keyWasGenerated) {
      console.log('\nðŸ“‹ IMPORTANT: New IndexNow key generated!');
      console.log('Add this to your GitHub Secrets as INDEXNOW_KEY:');
      console.log(`${indexNowKey}`);
      console.log('\nOr the system will continue using the auto-generated key from config file.');
    }
    
  } catch (error) {
    console.error('âœ— Failed to create IndexNow key files:', error.message);
  }
  
  return {
    key: indexNowKey,
    keyLocation: `${getBaseUrl()}/indexnow-key.txt`,
    wasGenerated: keyWasGenerated
  };
}

// Enhanced IndexNow submission with auto-retry
async function submitToIndexNow(urls, indexNowConfig, config) {
  if (!indexNowConfig.enabled || !indexNowConfig.key || urls.length === 0) {
    console.log('âš  IndexNow disabled, no key, or no URLs to submit');
    return false;
  }
  
  const baseUrl = getBaseUrl();
  const retryAttempts = config.pingServices?.retryAttempts || 2;
  
  for (let attempt = 1; attempt <= retryAttempts; attempt++) {
    try {
      const payload = {
        host: new URL(baseUrl).hostname,
        key: indexNowConfig.key,
        keyLocation: indexNowConfig.keyLocation,
        urlList: urls.slice(0, 10000) // IndexNow limit
      };
      
      console.log(`Attempt ${attempt}: Submitting ${urls.length} URLs to IndexNow...`);
      
      const response = await axios.post('https://api.indexnow.org/indexnow', payload, {
        headers: { 
          'Content-Type': 'application/json',
          'User-Agent': 'Hugo-IndexNow/1.0'
        },
        timeout: 15000
      });
      
      if (response.status === 200) {
        console.log(`âœ“ IndexNow: Successfully submitted ${urls.length} URLs`);
        
        // Update config with success info
        const configData = loadIndexingConfig();
        configData.indexNow.lastSubmission = {
          timestamp: new Date().toISOString(),
          urlCount: urls.length,
          status: 'success'
        };
        saveIndexingConfig(configData);
        
        return true;
      }
      
    } catch (error) {
      console.error(`âœ— IndexNow attempt ${attempt} failed: ${error.message}`);
      
      if (attempt < retryAttempts) {
        const delay = config.pingServices?.delayBetweenPings || 1000;
        console.log(`Retrying in ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  // Update config with failure info
  const configData = loadIndexingConfig();
  configData.indexNow.lastSubmission = {
    timestamp: new Date().toISOString(),
    urlCount: urls.length,
    status: 'failed'
  };
  saveIndexingConfig(configData);
  
  return false;
}

// Function to validate and test IndexNow configuration
async function testIndexNowConfiguration(indexNowConfig) {
  console.log('=== Testing IndexNow Configuration ===');
  
  try {
    // Test key file accessibility
    const keyUrl = indexNowConfig.keyLocation;
    const response = await axios.get(keyUrl, { timeout: 5000 });
    
    if (response.data.trim() === indexNowConfig.key) {
      console.log('âœ“ IndexNow key file is accessible and valid');
      return true;
    } else {
      console.error('âœ— IndexNow key file content mismatch');
      return false;
    }
    
  } catch (error) {
    console.error(`âœ— IndexNow key file test failed: ${error.message}`);
    return false;
  }
}

// Function to get recently updated URLs from sitemap
async function getRecentUrls(sitemapUrl, hoursAgo = 24) {
  try {
    const response = await axios.get(sitemapUrl, { timeout: 10000 });
    const xml = response.data;
    
    // Simple XML parsing to extract URLs and lastmod dates
    const urlMatches = xml.match(/<url>[\s\S]*?<\/url>/g) || [];
    const recentUrls = [];
    const cutoffDate = new Date(Date.now() - (hoursAgo * 60 * 60 * 1000));
    
    urlMatches.forEach(urlBlock => {
      const locMatch = urlBlock.match(/<loc>(.*?)<\/loc>/);
      const lastmodMatch = urlBlock.match(/<lastmod>(.*?)<\/lastmod>/);
      
      if (locMatch) {
        const url = locMatch[1];
        const lastmod = lastmodMatch ? new Date(lastmodMatch[1]) : new Date();
        
        if (lastmod >= cutoffDate) {
          recentUrls.push(url);
        }
      }
    });
    
    return recentUrls;
  } catch (error) {
    console.error('Error parsing sitemap:', error.message);
    return [];
  }
}

// Modern ping services
const pingServices = [
  {
    name: 'Google',
    url: 'https://www.google.com/ping?sitemap=',
    priority: 'high'
  },
  {
    name: 'Bing',
    url: 'https://www.bing.com/ping?sitemap=',
    priority: 'high'
  },
  {
    name: 'Yandex',
    url: 'https://webmaster.yandex.com/ping?sitemap=',
    priority: 'medium'
  }
];

// Enhanced ping function
async function pingSearchEngines() {
  const baseUrl = getBaseUrl();
  const fullSitemapUrl = `${baseUrl}/sitemap.xml`;
  const config = loadIndexingConfig();
  
  console.log(`Pinging sitemap: ${fullSitemapUrl}`);
  
  const results = { successful: 0, failed: 0, total: pingServices.length };
  
  // Ping traditional services
  for (const service of pingServices) {
    try {
      const response = await axios.get(`${service.url}${fullSitemapUrl}`, { 
        timeout: 15000,
        validateStatus: (status) => status < 500
      });
      
      if (response.status >= 200 && response.status < 400) {
        console.log(`âœ“ Successfully pinged ${service.name} (${response.status})`);
        results.successful++;
      } else {
        console.log(`âš  ${service.name} responded with status ${response.status}`);
        results.failed++;
      }
      
    } catch (error) {
      console.error(`âœ— Failed to ping ${service.name}: ${error.message}`);
      results.failed++;
    }
    
    await new Promise(resolve => setTimeout(resolve, config.pingServices?.delayBetweenPings || 500));
  }
  
  // IndexNow submission
  if (config.indexNow?.enabled) {
    console.log('\n=== IndexNow Submission ===');
    
    const indexNowConfig = autoConfigureIndexNow();
    
    // Test configuration
    const isConfigValid = await testIndexNowConfiguration(indexNowConfig);
    
    if (isConfigValid) {
      const hoursThreshold = config.indexNow?.hoursThreshold || 24;
      const recentUrls = config.indexNow?.submitRecentOnly 
        ? await getRecentUrls(fullSitemapUrl, hoursThreshold)
        : await getAllUrlsFromSitemap(fullSitemapUrl);
      
      if (recentUrls.length > 0) {
        console.log(`Found ${recentUrls.length} URLs for IndexNow submission`);
        await submitToIndexNow(recentUrls, indexNowConfig, config);
      } else {
        console.log('No URLs found for IndexNow submission');
      }
    }
  }
  
  console.log(`\nðŸ“Š Ping Results: ${results.successful}/${results.total} successful`);
  return results.successful > 0;
}

// Function to get all URLs from sitemap (for full submission)
async function getAllUrlsFromSitemap(sitemapUrl) {
  try {
    const response = await axios.get(sitemapUrl, { timeout: 10000 });
    const xml = response.data;
    
    const urlMatches = xml.match(/<loc>(.*?)<\/loc>/g) || [];
    return urlMatches.map(match => match.replace(/<\/?loc>/g, ''));
    
  } catch (error) {
    console.error('Error parsing sitemap for all URLs:', error.message);
    return [];
  }
}

// Function to run article_revisi_ai.pyc
function runArticleRevision() {
  try {
    console.log('Running article_revisi_ai.pyc...');
    
    const pythonScript = path.join(__dirname, '..', 'github', 'article_revisi_ai.pyc');
    
    if (!fs.existsSync(pythonScript)) {
      console.error('article_revisi_ai.pyc file not found at:', pythonScript);
      return false;
    }
    
    execSync(`python ${pythonScript}`, { 
      stdio: 'inherit',
      cwd: path.join(__dirname, '..', '..') 
    });
    
    console.log('âœ“ article_revisi_ai.pyc ran successfully');
    return true;
    
  } catch (error) {
    console.error('âœ— Error running article_revisi_ai.pyc:', error.message);
    return false;
  }
}

// Main function
async function main() {
  console.log('=== Starting Enhanced Recycle and Indexing Process ===');
  
  // Auto-configure IndexNow
  const indexNowConfig = autoConfigureIndexNow();
  
  // Run article revision
  const revisionSuccess = runArticleRevision();
  
  if (revisionSuccess) {
    console.log('\n=== Building Hugo site ===');
    
    try {
      // Rebuild Hugo site
      execSync('hugo --minify', { 
        stdio: 'inherit', 
        cwd: path.join(__dirname, '..', '..') 
      });
      console.log('âœ“ Hugo build successful');
      
      // Compress sitemap
      console.log('\n=== Processing sitemap ===');
      execSync('node core/tools/compress-sitemap.js', { 
        stdio: 'inherit',
        cwd: path.join(__dirname, '..', '..') 
      });
      
      // Search engine notification with IndexNow
      console.log('\n=== Notifying search engines ===');
      const pingSuccess = await pingSearchEngines();
      
      if (pingSuccess) {
        console.log('\nâœ… All processes completed successfully!');
        
        if (indexNowConfig.wasGenerated) {
          console.log('\nðŸ”‘ IndexNow Key Generated!');
          console.log('For better security, add this key to GitHub Secrets as INDEXNOW_KEY');
        }
        
        console.log('\nðŸ’¡ Indexing Status:');
        console.log('   â€¢ Traditional ping services: âœ“ Notified');
        console.log('   â€¢ IndexNow API: âœ“ Configured and active');
        console.log('   â€¢ Key file: âœ“ Accessible at /indexnow-key.txt');
        
      } else {
        console.log('\nâš  Build completed but search engine notification had issues');
      }
      
    } catch (error) {
      console.error('âœ— Error in build process:', error.message);
      process.exit(1);
    }
    
  } else {
    console.log('Process stopped because article revision failed.');
    process.exit(1);
  }
}

// Export for testing
module.exports = {
  generateIndexNowKey,
  autoConfigureIndexNow,
  testIndexNowConfiguration,
  submitToIndexNow
};

// Run main function
if (require.main === module) {
  main().catch(error => {
    console.error('Error in main process:', error);
    process.exit(1);
  });
}